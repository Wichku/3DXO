<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 4x4x4 Tic-Tac-Toe with Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@400;700&display=swap');
        
        body {
            font-family: 'Outfit', sans-serif;
        }

        .cell {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .cell:active {
            transform: scale(0.95);
        }

        /* X and O Colors */
        .text-x { color: #2563eb; } /* Blue-600 */
        .text-o { color: #dc2626; } /* Red-600 */

        /* Pop animation for placing marks */
        @keyframes popIn {
            0% { transform: scale(0); opacity: 0; }
            80% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); }
        }
        .pop-in {
            animation: popIn 0.3s forwards;
        }

        #canvas-container {
            background: radial-gradient(circle at center, #ffffff 0%, #f1f5f9 100%);
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen flex flex-col items-center p-4 text-slate-800">

    <div class="w-full max-w-6xl flex flex-col items-center">
        
        <!-- Header -->
        <div class="text-center mb-6 w-full">
            <h1 class="text-4xl font-bold bg-gradient-to-r from-blue-500 to-red-500 bg-clip-text text-transparent mb-2">
                3D XO 4x4x4
            </h1>
            <div class="flex justify-center items-center gap-4 mb-4">
                 <div class="inline-flex items-center gap-3 bg-white rounded-xl px-4 py-2 shadow-sm border border-gray-200">
                    <span class="text-sm font-semibold text-slate-500 uppercase tracking-wider">Turn:</span>
                    <span id="turn-indicator" class="text-xl font-bold text-blue-600">X</span>
                </div>
                <button onclick="resetGame()" 
                    class="bg-slate-800 hover:bg-slate-700 text-white font-bold py-2 px-4 rounded-xl transition-colors text-sm shadow-sm">
                    Restart
                </button>
            </div>
            <h2 id="status-message" class="text-lg font-medium text-slate-600 h-6">
                Game in progress...
            </h2>
        </div>

        <div class="flex flex-col md:flex-row w-full gap-6 items-start">
            
            <!-- 2D Input Boards (Left Half) -->
            <div class="w-full md:w-1/2 flex justify-center order-2 md:order-1">
                <div class="grid grid-cols-1 gap-6 w-full max-w-[240px]" id="boards-container">
                    <!-- Boards generated by JS -->
                </div>
            </div>

            <!-- 3D Visualization Container (Right Half) -->
            <div class="w-full md:w-1/2 flex flex-col order-1 md:order-2 sticky top-6">
                <div id="canvas-container" class="w-full aspect-square rounded-2xl shadow-lg border border-gray-200 relative overflow-hidden cursor-move">
                    <div class="absolute bottom-4 left-0 right-0 text-center pointer-events-none z-10">
                        <span class="bg-white/80 px-3 py-1 rounded-full text-xs text-slate-600 backdrop-blur-sm shadow-sm font-medium">Drag to Rotate View</span>
                    </div>
                    <div class="absolute bottom-2 right-3 text-[10px] text-slate-400 font-bold tracking-widest pointer-events-none z-10 opacity-60 select-none font-mono">
                        Wichku
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // --- GAME LOGIC ---
        const boardsContainer = document.getElementById('boards-container');
        const statusMessage = document.getElementById('status-message');
        const turnIndicator = document.getElementById('turn-indicator');
        
        let currentPlayer = 'X';
        let gameActive = true;
        let gameState = Array(64).fill(""); 
        let winningLines = [];

        // --- 3D SCENE VARIABLES ---
        let scene, camera, renderer, gridGroup;
        let cells3D = []; // Array to store mesh references
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        const canvasContainer = document.getElementById('canvas-container');

        // --- GAME INIT ---
        function initGame() {
            winningLines = generateWinningLines();
            renderBoards();
            init3D(); // Start 3D
            animate();
        }

        // --- 3D VISUALIZATION LOGIC ---
        function init3D() {
            // Scene Setup
            scene = new THREE.Scene();
            // No background color set here, we use CSS gradient for container

            // Camera
            const aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
            camera.position.z = 12;
            camera.position.y = 4;
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            canvasContainer.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            // Grid Group
            gridGroup = new THREE.Group();
            scene.add(gridGroup);

            // Create 4x4x4 Grid of Placeholders
            // Spacing: 1.5 units
            const spacing = 1.5;
            const offset = (3 * spacing) / 2; // To center the grid

            const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2); // Small dots for empty cells
            // Lighter color for visibility on white bg
            const material = new THREE.MeshBasicMaterial({ color: 0x94a3b8, transparent: true, opacity: 0.6 });

            for (let z = 0; z < 4; z++) { // Height (Layers)
                for (let y = 0; y < 4; y++) { // Rows
                    for (let x = 0; x < 4; x++) { // Cols
                        // Create visual marker
                        const mesh = new THREE.Mesh(geometry, material.clone());
                        
                        mesh.position.x = (x * spacing) - offset;
                        mesh.position.y = (z * spacing) - offset; // Levels stack up
                        mesh.position.z = (y * spacing) - offset;

                        gridGroup.add(mesh);
                        
                        const index = x + y * 4 + z * 16;
                        cells3D[index] = mesh;
                    }
                }
            }
            
            // Add a wireframe box around the whole play area for context
            const boxGeo = new THREE.BoxGeometry(4*spacing, 4*spacing, 4*spacing);
            // Light grey wireframe
            const boxMat = new THREE.MeshBasicMaterial({ color: 0xcbd5e1, wireframe: true, transparent: true, opacity: 0.8 });
            const boundingBox = new THREE.Mesh(boxGeo, boxMat);
            gridGroup.add(boundingBox);

            // Mouse Events for Rotation
            setupInteraction();

            // Handle Resize
            window.addEventListener('resize', onWindowResize, false);
        }

        function setupInteraction() {
            canvasContainer.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.offsetX, y: e.offsetY };
            });

            canvasContainer.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaMove = {
                        x: e.offsetX - previousMousePosition.x,
                        y: e.offsetY - previousMousePosition.y
                    };

                    const rotateSpeed = 0.005;
                    gridGroup.rotation.y += deltaMove.x * rotateSpeed;
                    gridGroup.rotation.x += deltaMove.y * rotateSpeed;

                    previousMousePosition = { x: e.offsetX, y: e.offsetY };
                }
            });

            window.addEventListener('mouseup', () => isDragging = false);
            
            // Touch support
            canvasContainer.addEventListener('touchstart', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }, {passive: false});

            canvasContainer.addEventListener('touchmove', (e) => {
                if(isDragging) {
                    e.preventDefault(); // Prevent scrolling
                    const deltaMove = {
                        x: e.touches[0].clientX - previousMousePosition.x,
                        y: e.touches[0].clientY - previousMousePosition.y
                    };
                    const rotateSpeed = 0.01;
                    gridGroup.rotation.y += deltaMove.x * rotateSpeed;
                    gridGroup.rotation.x += deltaMove.y * rotateSpeed;
                    previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
            }, {passive: false});
            
            window.addEventListener('touchend', () => isDragging = false);
        }

        function update3DCell(index, player) {
            const mesh = cells3D[index];
            if (!mesh) return;

            // Remove old geometry
            mesh.geometry.dispose();
            mesh.material.dispose();

            if (player === 'X') {
                // Blue Cube for X
                mesh.geometry = new THREE.BoxGeometry(1, 1, 1);
                mesh.material = new THREE.MeshStandardMaterial({ 
                    color: 0x2563eb, 
                    roughness: 0.3,
                    metalness: 0.2,
                    emissive: 0x1d4ed8,
                    emissiveIntensity: 0.1
                });
            } else {
                // Red Sphere for O
                mesh.geometry = new THREE.SphereGeometry(0.6, 32, 32);
                mesh.material = new THREE.MeshStandardMaterial({ 
                    color: 0xdc2626, 
                    roughness: 0.3,
                    metalness: 0.2,
                    emissive: 0xb91c1c,
                    emissiveIntensity: 0.1
                });
            }
            
            // Animate scale up (simple manual tween in animate loop or just set scale)
            mesh.scale.set(0.1, 0.1, 0.1);
            let targetScale = 1;
            
            // Simple expansion animation logic
            const expand = () => {
                if (mesh.scale.x < targetScale) {
                    mesh.scale.addScalar(0.1);
                    requestAnimationFrame(expand);
                }
            };
            expand();
        }

        function reset3D() {
            if(!cells3D.length) return;
            
            const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const material = new THREE.MeshBasicMaterial({ color: 0x94a3b8, transparent: true, opacity: 0.6 });

            cells3D.forEach(mesh => {
                mesh.geometry.dispose();
                mesh.material.dispose();
                mesh.geometry = geometry.clone();
                mesh.material = material.clone();
                mesh.scale.set(1, 1, 1);
            });
            
            // Reset Rotation slightly
            gridGroup.rotation.set(0, 0, 0);
        }

        function highlight3DWin(indices) {
            indices.forEach(index => {
                const mesh = cells3D[index];
                if (mesh) {
                    mesh.material.emissiveIntensity = 0.5;
                    mesh.material.color.setHex(0xfcd34d); // Gold/Yellow highlight
                }
            });
        }

        function onWindowResize() {
            if (!camera || !renderer) return;
            const width = canvasContainer.clientWidth;
            const height = canvasContainer.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        function animate() {
            requestAnimationFrame(animate);
            // No auto spin
            renderer.render(scene, camera);
        }


        // --- ORIGINAL GAME LOGIC UTILS ---

        function generateWinningLines() {
            const lines = [];
            const getIdx = (x, y, z) => x + y * 4 + z * 16;

            // 1. Orthogonal
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    lines.push([0, 1, 2, 3].map(k => getIdx(k, i, j)));
                    lines.push([0, 1, 2, 3].map(k => getIdx(i, k, j)));
                    lines.push([0, 1, 2, 3].map(k => getIdx(i, j, k)));
                }
            }

            // 2. 2D Diagonals
            for (let i = 0; i < 4; i++) {
                lines.push([0, 1, 2, 3].map(k => getIdx(k, k, i)));
                lines.push([0, 1, 2, 3].map(k => getIdx(3 - k, k, i)));
                lines.push([0, 1, 2, 3].map(k => getIdx(k, i, k)));
                lines.push([0, 1, 2, 3].map(k => getIdx(3 - k, i, k)));
                lines.push([0, 1, 2, 3].map(k => getIdx(i, k, k)));
                lines.push([0, 1, 2, 3].map(k => getIdx(i, 3 - k, k)));
            }

            // 3. 3D Main Diagonals
            lines.push([0, 1, 2, 3].map(k => getIdx(k, k, k)));
            lines.push([0, 1, 2, 3].map(k => getIdx(3 - k, k, k)));
            lines.push([0, 1, 2, 3].map(k => getIdx(k, 3 - k, k)));
            lines.push([0, 1, 2, 3].map(k => getIdx(3 - k, 3 - k, k)));

            return lines;
        }

        function renderBoards() {
            boardsContainer.innerHTML = '';
            
            // Loop from top (Level 4) to bottom (Level 1) so Level 1 is visually at the bottom
            for (let z = 3; z >= 0; z--) {
                const levelWrapper = document.createElement('div');
                levelWrapper.className = "flex flex-col items-center w-full";

                const levelTitle = document.createElement('div');
                levelTitle.className = "text-slate-500 font-bold mb-2 uppercase tracking-widest text-xs";
                levelTitle.innerText = `Level ${z + 1}`;
                levelWrapper.appendChild(levelTitle);

                // Updated colors for light mode
                const grid = document.createElement('div');
                grid.className = "grid grid-cols-4 grid-rows-4 gap-1.5 bg-white p-2 rounded-xl shadow-md border border-gray-200 aspect-square w-full max-w-[200px]";
                
                for (let y = 0; y < 4; y++) {
                    for (let x = 0; x < 4; x++) {
                        const index = x + y * 4 + z * 16;
                        const cellElement = document.createElement('div');
                        
                        // Updated cell colors for light mode
                        cellElement.classList.add(
                            'cell', 'bg-gray-100', 'rounded', 'cursor-pointer', 
                            'flex', 'items-center', 'justify-center', 
                            'text-xl', 'font-bold', 'shadow-sm',
                            'hover:bg-gray-200', 'select-none', 'overflow-hidden'
                        );
                        
                        cellElement.setAttribute('data-index', index);
                        cellElement.addEventListener('click', handleCellClick);
                        grid.appendChild(cellElement);
                    }
                }
                levelWrapper.appendChild(grid);
                boardsContainer.appendChild(levelWrapper);
            }
        }

        function handleCellClick(e) {
            const clickedCell = e.target;
            const clickedCellIndex = parseInt(clickedCell.getAttribute('data-index'));

            if (gameState[clickedCellIndex] !== "" || !gameActive) {
                return;
            }

            handleCellPlayed(clickedCell, clickedCellIndex);
            handleResultValidation();
        }

        function handleCellPlayed(cell, index) {
            gameState[index] = currentPlayer;
            
            // 2D UI Update
            const span = document.createElement('span');
            span.innerText = currentPlayer;
            span.classList.add('pop-in');
            if (currentPlayer === 'X') {
                span.classList.add('text-x');
            } else {
                span.classList.add('text-o');
            }
            cell.appendChild(span);

            // 3D UI Update
            update3DCell(index, currentPlayer);
        }

        function handleResultValidation() {
            let roundWon = false;
            let winningLineIndices = [];

            for (let i = 0; i < winningLines.length; i++) {
                const line = winningLines[i];
                const a = gameState[line[0]];
                const b = gameState[line[1]];
                const c = gameState[line[2]];
                const d = gameState[line[3]];

                if (a === '' || b === '' || c === '' || d === '') continue;

                if (a === b && b === c && c === d) {
                    roundWon = true;
                    winningLineIndices = line;
                    break;
                }
            }

            if (roundWon) {
                gameActive = false;
                statusMessage.innerHTML = `<span class="${currentPlayer === 'X' ? 'text-blue-600' : 'text-red-600'} font-bold">Player ${currentPlayer} Wins!</span> ðŸŽ‰`;
                highlightWinningCells(winningLineIndices);
                highlight3DWin(winningLineIndices);
                return;
            }

            let roundDraw = !gameState.includes("");
            if (roundDraw) {
                gameActive = false;
                statusMessage.innerText = "It's a Draw! ðŸ¤";
                turnIndicator.innerText = "-";
                turnIndicator.className = "text-xl font-bold text-slate-400";
                return;
            }

            handlePlayerChange();
        }

        function handlePlayerChange() {
            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
            turnIndicator.innerText = currentPlayer;
            turnIndicator.className = `text-xl font-bold ${currentPlayer === 'X' ? 'text-blue-600' : 'text-red-600'}`;
            statusMessage.innerText = `Player ${currentPlayer}'s turn`;
        }

        function highlightWinningCells(indices) {
            const cells = document.querySelectorAll('.cell');
            indices.forEach(index => {
                const cell = [...cells].find(c => parseInt(c.getAttribute('data-index')) === index);
                if(cell) {
                    cell.classList.remove('bg-gray-100', 'hover:bg-gray-200');
                    if (currentPlayer === 'X') {
                        cell.classList.add('bg-blue-100', 'ring-2', 'ring-blue-500', 'ring-inset');
                    } else {
                        cell.classList.add('bg-red-100', 'ring-2', 'ring-red-500', 'ring-inset');
                    }
                }
            });
        }

        function resetGame() {
            gameActive = true;
            currentPlayer = "X";
            gameState = Array(64).fill(""); 
            statusMessage.innerText = "Player X's turn";
            
            turnIndicator.innerText = "X";
            turnIndicator.className = "text-xl font-bold text-blue-600";

            // Reset 2D
            document.querySelectorAll('.cell').forEach(cell => {
                cell.innerHTML = "";
                // Reset to light mode classes
                cell.className = "cell bg-gray-100 rounded cursor-pointer flex items-center justify-center text-xl font-bold shadow-sm hover:bg-gray-200 select-none overflow-hidden";
            });

            // Reset 3D
            reset3D();
        }

        // Start
        initGame();
    </script>
</body>
</html>
